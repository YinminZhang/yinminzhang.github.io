<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[setup]]></title>
    <url>%2F2021%2F06%2F24%2F1%2F</url>
    <content type="text"><![CDATA[Setup a New Machine!Download, compile and install commonly used software to a custom path. Environment macOS Catalina 10.15.6 (19G73) MacBook Pro (13-inch, 2018, Four Thunderbolt 3 Ports) Processor 2.3 GHz Quad-Core Intel Core i5 Memory 16 GB 2133 MHz LPDDR3 Graphics Intel Iris Plus Graphics 655 1536 MBDarwin 19.6.0 Darwin Kernel Version 19.6.0: Sun Jul 5 00:43:10 PDT 2020; root:xnu-6153.141.1~9/RELEASE_X86_64 x86_64 Term of UsageUsage# configure setup path, you can put them into your `.bashrc` or `.zshrc` # e.g. install git # Install oh my zsh, Oh My Zsh is an open source, community-driven framework for managing your zsh configuration. sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; # Install Vundle, Vundle is short for Vim bundle and is a Vim plugin manager. git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim vim +PluginInstall +qall # Update config. git clone https://github.com/YinminZhang/setup.git cp vimrc ~/.vimrc &amp;&amp; cp zshrc ~/.zshrc source ~/.zshrc Table of Contents iTerm2 zsh vim tmux iTerm2FontAfter font config, the iTerm2 can display many icons. First, we download fonts package. brew tap homebrew/cask-fonts brew cask install font-hack-nerd-font Then, we config the font in iTerm2. Preferences -&gt; Profiles -&gt; Open Profiles -&gt; Edit Profiles -&gt; Text Transparancy &amp; BackgroundWe can set image as iTerm2 background. Preferences -&gt; Profiles -&gt; Open Profiles -&gt; Edit Profiles -&gt; Window Advanced featureStatus bar Preferences -&gt; Profiles -&gt; Open Profiles -&gt; Edit Profiles -&gt; Session zshOh My Zsh is an open source, community-driven framework for managing your zsh configuration.We can install oh my zsh trough curl or wget. # curl sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; # wget sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; I recommend some plugin to improve your develop efficiency. # complete git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions # highlight git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting # autojump git clone git://github.com/wting/autojump.git &amp;&amp; cd autojump &amp;&amp; ./install.py You should config plugins in ~/.zshrc and run source ~/.zshrc to make sure the plugins to take effect. Theme # powerlevel10k git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k Then, we config ~/.zshrc, set ZSH_THEME to powerlevel10k/powerlevel10k and source ~/.zshrc. vim# ultimate vimrc Awesome version git clone --depth=1 https://github.com/amix/vimrc.git ~/.vim_runtime sh ~/.vim_runtime/install_awesome_vimrc.sh # Vundle is short for Vim bundle and is a Vim plugin manager. git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim vim +PluginInstall +qall # undo &amp;&amp; redo(ctrl+r) # echo &quot;set undofile&quot; &gt;&gt; ~/.vimrc # echo &quot;set undodir=~/.vim/undodir&quot; &gt;&gt; ~/.vimrc mkdir ~/.vim/undodir tmuxTBD]]></content>
  </entry>
  <entry>
    <title><![CDATA[VSCode]]></title>
    <url>%2F2021%2F01%2F10%2F1%2F</url>
    <content type="text"><![CDATA[vscode configureExtensionPython Python Python extension for Visual Studio Code. Python Indent Correct python indentation in Visual Studio Code. Python snippets Python snippets collections. Python Docstring Generator Visual Studio Code extension to quickly generate docstrings for python functions.Remote SFTP sftp sync extension for VS Code. Remote - SSH The Remote - SSH extension lets you use any remote machine with a SSH server as your development environment. C++ C/C++ The C/C++ extension adds language support for C/C++ to Visual Studio Code, including features such as IntelliSense and debugging. CodeLLDB Debugging on Linux (x64 or ARM), macOS and Windows. C/C++ Clang Command Adapter Completion and Diagnostic for C/C++/Objective-C using Clang command. clangd Provides C/C++ language IDE features for VS Code using clangd:Autocomplete and IntelliSense Visual Studio IntelliCode Kite Autocomplete Plugin for Visual Studio Code Others Jupyter Extension for Visual Studio Code IntelliJ IDEA Key Bindings Port of IntelliJ IDEA key bindings for VS Code. Includes keymaps for popular JetBrains products like IntelliJ Ultimate, WebStorm, PyCharm, PHP Storm, etc. language-stylus Adds syntax highlighting and code completion to Stylus files in Visual Studio Code. Markdown PDF This extension converts Markdown files to pdf, html, png or jpeg files. Markdown Preview Enhanced Markdown Preview Enhanced is an extension that provides you with many useful functionalities such as automatic scroll sync, math typesetting, mermaid, PlantUML, pandoc, PDF export, code chunk, presentation writer, etc. LaTeX Workshop LaTeX Workshop is an extension for Visual Studio Code, aiming to provide core features for LaTeX typesetting with Visual Studio Code. ConfigurePythonConfigure environmentSelect environment for python.command + p -&gt; &gt;select interpreterorcommand + shift + p -&gt; select interpreter Debug Extension Python configure launch.json and save launch.json.{ // Python debug configurations in Visual Studio Code: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;python: debug&quot;, // Provides the name for the debug configuration that appears in the VS Code drop-down list. &quot;type&quot;: &quot;python&quot;, &quot;request&quot;: &quot;launch&quot;, // [&#39;launch&#39;, &#39;attach&#39;] // launch: start the debugger on the file specified in program // attach: attach the debugger to an already running process. &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, // Specifies the current working directory for the debugger, which is the base folder for any relative paths used in code. &quot;program&quot;: &quot;${file}&quot;, // Provides the fully qualified path to the python program&#39;s entry module (startup file). &quot;console&quot;: &quot;integratedTerminal&quot;, // Specifies how program output is displayed &quot;args&quot;: [ &quot;--config&quot;, &quot;configcenternet3d_2x.yaml&quot; ] // Specifies arguments to pass to the Python program. } ] } recommand configure for local debugging as following:{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;python: debug&quot;, &quot;type&quot;: &quot;python&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;program&quot;: &quot;${workspaceFolder}/relative/path/filename.py &quot;, &quot;console&quot;: &quot;integratedTerminal&quot;, &quot;args&quot;: [ &quot;--config&quot;, &quot;configcenternet3d_2x.yaml&quot; ] } ] } command + 5 switch to RUN or f5. C++Configure PATH search include path list. gcc -v -E -x c - command + shift + p -&gt; c/c++&quot; Edit Configure type include path list to include path. Debug Extension C/C++ C/C++ Clang Command Adapter CodeLLDB configure launch.json and tasks.json. launch.json{ &quot;name&quot;: &quot;Launch&quot;, &quot;type&quot;: &quot;lldb&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${workspaceFolder}/{fileBasenameNoExtension}&quot;, // ${workspaceFolder}/&lt;my program&gt; &quot;args&quot;: [&quot;-arg1&quot;, &quot;-arg2&quot;], &quot;preLaunchTask&quot;: &quot;Build with Clang&quot; } tasks.json{ &quot;tasks&quot;: [ { &quot;label&quot;: &quot;Build with Clang&quot;, // same with launch[&quot;preLaunchTask&quot;] &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;clang++&quot;, &quot;args&quot;: [ &quot;-std=c++17&quot;, &quot;-stdlib=libc++&quot;, &quot;${fileBasenameNoExtension}.cpp&quot;, &quot;-o&quot;, &quot;${fileBasenameNoExtension}&quot;, &quot;--debug&quot; ], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ], &quot;version&quot;: &quot;2.0.0&quot; } command + 5 switch to RUN or f5. RemoteRemote - SSH Access remote server to modify, upload and download files. Access remote server to run file(python, cpp etc.). command + shift + p -&gt; remote-ssh: open configuration fileselect config path. config # Read more about SSH config files: https://linux.die.net/man/5/ssh_config Host Name HostName ip # Specifies the real host name to log into. For example, 220.181.38.150 User zhangsan # username Specifies the user to log in as. Port 22 # Specifies the port number to connect on the remote host. The default is 22. select server and file directory to access.]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Discrete Harmonic Map]]></title>
    <url>%2F2019%2F06%2F25%2F1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Discrete Harmonic Map (DHM) parameterizes disk-like surfaces by minimizing the Dirichlet energy of the (piece-wise linear) mapping functions. It is super easy to implement (if you are familiar with cotangent-weight Laplacian and have a linear solver at hand, it should take no more than a few hours) and generally gives good results. If you never heard about it, Misha’s class note might be helpful. Source CodeCotangent Edge Weighttemplate&lt;typename M&gt; void CHarmonicMapper&lt;M&gt;::_calculate_edge_weight() { //compute edge length for (M::MeshEdgeIterator eiter(m_pMesh); !eiter.end(); ++eiter) { M::CEdge* pE = *eiter; M::CVertex* v1 = m_pMesh-&gt;edgeVertex1(pE); M::CVertex* v2 = m_pMesh-&gt;edgeVertex2(pE); pE-&gt;length() = (v1-&gt;point() - v2-&gt;point()).norm(); } //compute corner angle for (M::MeshEdgeIterator eiter(m_pMesh); !eiter.end(); ++eiter) { M::CEdge* pE = *eiter; if (pE-&gt;boundary()) continue; for (int i = 0; i &lt; 2; ++i) { M::CHalfEdge* h = m_pMesh-&gt;edgeHalfedge(pE, i); double h_j = m_pMesh-&gt;halfedgeEdge((M::CHalfEdge*)h-&gt;he_next())-&gt;length(); double h_k = m_pMesh-&gt;halfedgeEdge((M::CHalfEdge*)h-&gt;he_prev())-&gt;length(); h-&gt;angle() = _inverse_cosine_law(h_j, h_k, pE-&gt;length()); } } //compute edge weight for (M::MeshEdgeIterator eiter(m_pMesh); !eiter.end(); ++eiter) { M::CEdge* pE = *eiter; M::CHalfEdge* h0 = m_pMesh-&gt;edgeHalfedge(pE, 0); M::CHalfEdge* h1 = m_pMesh-&gt;edgeHalfedge(pE, 1); pE-&gt;weight() = 0.5 * (1 / tan(h0-&gt;angle() + 1 / tan(h1-&gt;angle()))); } } Set Boundary Conditiontemplate&lt;typename M&gt; void CHarmonicMapper&lt;M&gt;::_set_boundary() { //get the boundary half edge loop std::vector&lt;M::CLoop*&gt; &amp; pLs = m_boundary.loops(); assert( pLs.size() == 1 ); M::CLoop * pL = pLs[0]; std::list&lt;M::CHalfEdge*&gt; &amp; pHs = pL-&gt;halfedges(); //compute the total length of the boundary double total_length = pL-&gt;length(); //parameterize the boundary using arc length parameter double current_length = 0; for (std::list&lt;M::CHalfEdge*&gt;::iterator hiter = pHs.begin(); hiter != pHs.end(); hiter++) { M::CHalfEdge* pH = *hiter; M::CEdge* pE = m_pMesh-&gt;halfedgeEdge(pH); current_length += pE-&gt;length(); double angle = 2 * PI / total_length * current_length; MeshLib::CPoint2* huv = new MeshLib::CPoint2(0.5 + 0.5 * cos(angle), 0.5 + 0.5 * sin(angle)); M::CVertex* pV = m_pMesh-&gt;halfedgeTarget(pH); pV-&gt;huv() = *huv; } } Iterative Algorithm for Harmonic Maptemplate&lt;typename M&gt; void CHarmonicMapper&lt;M&gt;::_iterative_map( double epsilon ) { //fix the boundary _set_boundary(); //move interior each vertex to its center of neighbors for (M::MeshVertexIterator viter(m_pMesh); !viter.end(); ++viter) { M::CVertex* pV = *viter; if (pV-&gt;boundary()) continue; MeshLib::CPoint2* huv = new MeshLib::CPoint2(0, 0); pV-&gt;huv() = *huv; } while (true) { double error = -1e+10; //move interior each vertex to its center of neighbors for (M::MeshVertexIterator viter(m_pMesh); !viter.end(); ++viter) { M::CVertex* pV = *viter; if (pV-&gt;boundary()) continue; double total_weight = 0; CPoint2 huv(0, 0); for (M::VertexVertexIterator vviter(pV); !vviter.end(); ++vviter) { M::CVertex* pW = *vviter; M::CEdge* pE = m_pMesh-&gt;vertexEdge(pV, pW); double weight = pE-&gt;weight(); total_weight += weight; huv = huv + pW-&gt;huv() * weight; } huv = huv / total_weight; double _error = (pV-&gt;huv() - huv).norm(); error = (_error &gt; error) ? _error : error; pV-&gt;huv() = huv; } if (error &lt; epsilon) break; } } Direct Algorithm for Harmonic Map (Extra Credit) &amp; Numerical Methodtemplate&lt;typename M&gt; void CHarmonicMapper&lt;M&gt;::_map() { //fix the boundary _set_boundary(); std::vector&lt;Eigen::Triplet&lt;double&gt; &gt; A_coefficients; std::vector&lt;Eigen::Triplet&lt;double&gt; &gt; B_coefficients; //set the matrix A for( M::MeshVertexIterator viter( m_pMesh ); !viter.end(); ++ viter ) { M::CVertex * pV = *viter; if( pV-&gt;boundary() ) continue; int vid = pV-&gt;idx(); double sw = 0; for( M::VertexVertexIterator witer( pV ); !witer.end(); ++ witer ) { M::CVertex * pW = *witer; int wid = pW-&gt;idx(); M::CEdge * e = m_pMesh-&gt;vertexEdge( pV, pW ); double w = e-&gt;weight(); if( pW-&gt;boundary() ) { B_coefficients.push_back( Eigen::Triplet&lt;double&gt;(vid,wid,w) ); } else { A_coefficients.push_back( Eigen::Triplet&lt;double&gt;(vid,wid, -w) ); } sw += w; } A_coefficients.push_back( Eigen::Triplet&lt;double&gt;(vid,vid, sw ) ); } Eigen::SparseMatrix&lt;double&gt; A( m_interior_vertices, m_interior_vertices ); A.setZero(); Eigen::SparseMatrix&lt;double&gt; B( m_interior_vertices, m_boundary_vertices ); B.setZero(); A.setFromTriplets(A_coefficients.begin(), A_coefficients.end()); B.setFromTriplets(B_coefficients.begin(), B_coefficients.end()); Eigen::ConjugateGradient&lt;Eigen::SparseMatrix&lt;double&gt;&gt; solver; std::cerr &lt;&lt; &quot;Eigen Decomposition&quot; &lt;&lt; std::endl; solver.compute(A); std::cerr &lt;&lt; &quot;Eigen Decomposition Finished&quot; &lt;&lt; std::endl; if( solver.info() != Eigen::Success ) { std::cerr &lt;&lt; &quot;Waring: Eigen decomposition failed&quot; &lt;&lt; std::endl; } for( int k = 0; k &lt; 2; k ++ ) { Eigen::VectorXd b(m_boundary_vertices); //set boundary constraints b vector for (M::MeshVertexIterator viter(m_pMesh); !viter.end(); ++viter) { M::CVertex* pV = *viter; if (!pV-&gt;boundary()) continue; int id = pV-&gt;idx(); b(id) = pV-&gt;huv()[k]; } Eigen::VectorXd c(m_interior_vertices); c = B * b; Eigen::VectorXd x = solver.solve(c); if( solver.info() != Eigen::Success ) { std::cerr &lt;&lt; &quot;Waring: Eigen decomposition failed&quot; &lt;&lt; std::endl; } //set the images of the harmonic map to interior vertices for (M::MeshVertexIterator viter(m_pMesh); !viter.end(); ++viter) { M::CVertex* pV = *viter; if (pV-&gt;boundary()) continue; int id = pV-&gt;idx(); pV-&gt;huv()[k] = x(id); } } } AlgorithmCotangent Edge WeightCompute edge lengthCompute the edge length, suppose $e = [v_i , v_j ]$, then$$l(e) = |v_j − v_i |.$$ - use $MeshEdgeIterator$ to find all of edges on m_pMesh - use $m_pMesh->halfedgeVertex1(Edge)$ to find the first vertex of an edge - use $m_pMesh->halfedgeVertex2(Edge)$ to find the second vertex of an edge - $point.norm()$ calculate the norm of the CPoint $\sqrt{x^2+y^2+z^2}$ for (M::MeshEdgeIterator eiter(m_pMesh); !eiter.end(); ++eiter) { M::CEdge* pE = *eiter; M::CVertex* v1 = m_pMesh-&gt;edgeVertex1(pE); M::CVertex* v2 = m_pMesh-&gt;edgeVertex2(pE); pE-&gt;length() = (v1-&gt;point() - v2-&gt;point()).norm(); } Compute corner angle Compute the corner angles of each triangular face, suppose $[v_i , v_j , v_k ]$ is a face, with edges $e_i , e_j , e_k ,$ where e_i is against the vertex v_i . The corresponding edge lengths are $l_i , l_j$ and $l_k$ . The inversive cosine law gives $$ \theta_i = acos \frac {l_j^2 + l_k^2 -l_i^2} {2 l_j l_k} $$ - use $MeshEdgeIterator$ to find all of edges on m_pMesh - use $pE->boundary()$ to judge whether the edge is on the boundary - use $m_pMesh->halfedgeEdge(halfedge)$ to attach halfedge to an edge - use $halfedge->he\_next()$ to find the next halfedge of a halfedge - $\_inverse\_cosine\_law(l_j,l_k,l_i)$ calculate the acos for (M::MeshEdgeIterator eiter(m_pMesh); !eiter.end(); ++eiter) { M::CEdge* pE = *eiter; if (pE-&gt;boundary()) continue; for (int i = 0; i &lt; 2; ++i) { M::CHalfEdge* h = m_pMesh-&gt;edgeHalfedge(pE, i); double h_j = m_pMesh-&gt;halfedgeEdge((M::CHalfEdge*)h-&gt;he_next())-&gt;length(); double h_k = m_pMesh-&gt;halfedgeEdge((M::CHalfEdge*)h-&gt;he_prev())-&gt;length(); h-&gt;angle() = _inverse_cosine_law(h_j, h_k, pE-&gt;length()); } } Compute edge weight The cotangent edge weight is as follows. Suppose edge $[v_i , v_j , v_k ] $ and $[v_j , v_i , v_l ]$ share an edge $[v_i , v_j ]$, then $$w_{ij}=\frac 1 2 (cot\theta_k^{ij} + cot\theta_l^{ji})$$ - use $Edge->weight()$ to get the weight of edge - use $HalfEdge->angle()$ to get the angle of halfege - use $1/ tan(\theta)$ to calculate $cot\theta$ for (M::MeshEdgeIterator eiter(m_pMesh); !eiter.end(); ++eiter) { M::CEdge* pE = *eiter; M::CHalfEdge* h0 = m_pMesh-&gt;edgeHalfedge(pE, 0); M::CHalfEdge* h1 = m_pMesh-&gt;edgeHalfedge(pE, 1); pE-&gt;weight() = 0.5 * (1 / tan(h0-&gt;angle() + 1 / tan(h1-&gt;angle()))); } Set Boundary ConditionGet the boundary half edge loop - use $Boundary.loops()$ to get the list of boundary loops - use $Loop->halfedge()$ to get the the list of haledges on the current boundary loop std::vector&lt;M::CLoop*&gt; &amp; pLs = m_boundary.loops(); assert( pLs.size() == 1 ); M::CLoop * pL = pLs[0]; std::list&lt;M::CHalfEdge*&gt; &amp; pHs = pL-&gt;halfedges(); Compute the total length of the boundary Suppose the boundary vertices are sorted counter-clock-wisely, as $\{v_0 , v_1 , · · · , v_{n−1} \}$. The total length of the boundary is given by $$s = \sum_{i=0}^{n-1}|v_{i+1}-v_i| $$ - use $Loop->length()$ to get the length of the current boundary loop double total_length = pL-&gt;length(); Parameterize the boundary using arc length parameter The image of $v_i \in \partial M$ is given by $$\begin{cases} \theta_i = \frac {2\pi} s \sum_{j=0}^{i-1}|v_{j+1}- v_j|\\ \phi(v_i)=(\frac {1+cos\theta_i} 2, \frac {1+sin\theta_i} 2) \end{cases}$$ double current_length = 0; for (std::list&lt;M::CHalfEdge*&gt;::iterator hiter = pHs.begin(); hiter != pHs.end(); hiter++) { M::CHalfEdge* pH = *hiter; M::CEdge* pE = m_pMesh-&gt;halfedgeEdge(pH); current_length += pE-&gt;length(); double angle = 2 * PI / total_length * current_length; MeshLib::CPoint2* huv = new MeshLib::CPoint2(0.5 + 0.5 * cos(angle), 0.5 + 0.5 * sin(angle)); M::CVertex* pV = m_pMesh-&gt;halfedgeTarget(pH); pV-&gt;huv() = *huv; } Iterative Algorithm for Harmonic Map First, for each interior vertex $v_i \notin \partial M$, set $\phi(v_i ) = (0, 0)$. Second, for each interior vertex, move its image to the mass center of the images of its neighbors, $$c_i = \frac {\sum_j w_{ij}\phi(v_j)} {\sum_j w_ij}, \phi(v_i)\leftarrow c_i$$ repeat this procedure, until the algorithm converges. For each interior vertex $v_i \notin \partial M$, set $\phi(v_i ) = (0, 0)$ - use $pE->boundary()$ to judge whether the edge is on the boundary for (M::MeshVertexIterator viter(m_pMesh); !viter.end(); ++viter) { M::CVertex* pV = *viter; if (pV-&gt;boundary()) continue; MeshLib::CPoint2* huv = new MeshLib::CPoint2(0, 0); pV-&gt;huv() = *huv; } Move interior each vertex to its center of neighbors - use $MeshVertexIterator$ to find all of edges on m_pMesh - use $VertexVertexIterator$ to transverse all the neighboring vertices of a vertex - use $Edge->vertexEdge(vertex0, vertex2)$ to access an edge by its two end vertices - use $m_pMesh->weight()$ to get the weight of edge - use $Vertex->huv()$ to get the $\phi(v_i)$ of interior vertex while (true) { double error = -1e+10; for (M::MeshVertexIterator viter(m_pMesh); !viter.end(); ++viter) { M::CVertex* pV = *viter; if (pV-&gt;boundary()) continue; double total_weight = 0; CPoint2 huv(0, 0); for (M::VertexVertexIterator vviter(pV); !vviter.end(); ++vviter) { M::CVertex* pW = *vviter; M::CEdge* pE = m_pMesh-&gt;vertexEdge(pV, pW); double weight = pE-&gt;weight(); total_weight += weight; huv = huv + pW-&gt;huv() * weight; } huv = huv / total_weight; double _error = (pV-&gt;huv() - huv).norm(); error = (_error &gt; error) ? _error : error; pV-&gt;huv() = huv; } if (error &lt; epsilon) break; } Direct Algorithm for Harmonic Map (Extra Credit)For each interior vertex $v_i \notin \partial M$, establish one linear equation $$\sum_j w_{ij}(\phi(v_i)-\phi(v_j)) = 0$$ solve this sparse linear system, the result is the harmonic map. //set boundary constraints b vector for (M::MeshVertexIterator viter(m_pMesh); !viter.end(); ++viter) { M::CVertex* pV = *viter; if (!pV-&gt;boundary()) continue; int id = pV-&gt;idx(); b(id) = pV-&gt;huv()[k]; } //set the images of the harmonic map to interior vertices for (M::MeshVertexIterator viter(m_pMesh); !viter.end(); ++viter) { M::CVertex* pV = *viter; if (pV-&gt;boundary()) continue; int id = pV-&gt;idx(); pV-&gt;huv()[k] = x(id); } This assignment uses Eigen library to solve large sparse linear system. The following commands will be useful. std::vector&lt;Eigen::Triplet&lt;double&gt; &gt; A_coefficients; A_coefficients.push_back( Eigen::Triplet&lt;double&gt;(vid,wid, -w) ); Eigen::SparseMatrix&lt;double&gt; A( m_interior_vertices, m_interior_vertices ); A.setZero(); A.setFromTriplets(A_coefficients.begin(), A_coefficients.end()); Eigen::ConjugateGradient&lt;Eigen::SparseMatrix&lt;double&gt;&gt; solver; std::cerr &lt;&lt; &quot;Eigen Decomposition&quot; &lt;&lt; std::endl; solver.compute(A); std::cerr &lt;&lt; &quot;Eigen Decomposition Finished&quot; &lt;&lt; std::endl; if( solver.info() != Eigen::Success ) { std::cerr &lt;&lt; &quot;Waring: Eigen decomposition failed&quot; &lt;&lt; std::endl; } Eigen::VectorXd b(m_boundary_vertices); Eigen::VectorXd x = solver.solve(c); if( solver.info() != Eigen::Success ) { std::cerr &lt;&lt; &quot;Waring: Eigen decomposition failed&quot; &lt;&lt; std::endl; } ResultIn this section, we show the result of harmonic mapping separately. Direct Algorithm for Harmonic Map(Fig. 3.1 &amp; Fig. 3.2) Iterative Algorithm for Harmonic Map(Fig. 3.3) Fig. 3.1. Harmonic Map On Alex Fig. 3.2. Harmonic Map On Sophie Fig. 3.3. Iterative Harmonic Map On Sophie Data from sophie.uv.m Vertex 54475 103.073 50.793 26.4526 {rgb=(0.117956 0.117956 0.117956) uv=(0.999907 0.490347)} Vertex 54480 107.076 50.7952 27.7994 {rgb=(0.151779 0.151779 0.151779) uv=(0.999013 0.468605)} Vertex 54487 108.817 50.7937 28.1584 {rgb=(0.156541 0.156541 0.156541) uv=(0.998355 0.459469)} Vertex 54496 114.037 50.795 29.4016 {rgb=(0.174857 0.174857 0.174857) uv=(0.995353 0.431987)} Vertex 54505 117.28 50.7941 29.6458 {rgb=(0.16433 0.16433 0.16433) uv=(0.992795 0.415427)}Data generated by Direct Algorithm for Harmonic Map Vertex 54475 0.999907 0.490347 0 {rgb=(0.117956 0.117956 0.117956)} Vertex 54480 0.999013 0.468605 0 {rgb=(0.151779 0.151779 0.151779)} Vertex 54487 0.998355 0.459469 0 {rgb=(0.156541 0.156541 0.156541)} Vertex 54496 0.995353 0.431987 0 {rgb=(0.174857 0.174857 0.174857)} Vertex 54505 0.992795 0.415427 0 {rgb=(0.16433 0.16433 0.16433)}Data generated by Iterative Algorithm for Harmonic Map Vertex 54475 0.999907 0.490347 0 {rgb=(0.117956 0.117956 0.117956)} Vertex 54480 0.999013 0.468605 0 {rgb=(0.151779 0.151779 0.151779)} Vertex 54487 0.998355 0.459469 0 {rgb=(0.156541 0.156541 0.156541)} Vertex 54496 0.995353 0.431987 0 {rgb=(0.174857 0.174857 0.174857)} Vertex 54505 0.992795 0.415427 0 {rgb=(0.16433 0.16433 0.16433)}]]></content>
      <categories>
        <category>Computer vision</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Computer vision</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Image Warpper]]></title>
    <url>%2F2019%2F06%2F23%2F1%2F</url>
    <content type="text"><![CDATA[Bezier Curve Evaluation AlgorithmA bézier line is an arc that is strictly based on a set number of points instead of on an ellipse. A bézier curve uses at least four points to draw on. Bézier curves can be combined to form a Bézier spline, or generalized to higher dimensions to form Bézier surfaces Linear Bézier curvesGiven distinct points $P_0$ and $P_1$, a linear Bézier curve is simply a straight line between those two points. The curve is given by$$B ( t ) = P_0 + t ( P_1-P_0) = (1 - t)P_0 + tP_1 , 0 \leq t \leq 1$$The coeficients, $b_i$ are the control points or Bézier points and together with the basis function $B_{i,n}(t)$determine the shape of the curve. Lines drawn between consecutive control points of the curve form the control polygon. A cubic Bezier curve together with its control polyg`on is shown in Fig. 1.1. Bezier curves have the following properties: Geometry invariance property: Partition of unity property of the Bernstein polynomial assures the invariance of the shape of the Bézier curve under translation and rotation of its control points ![avatar](./Bezier curve.png)Fig. 1.1. $Slerp(p, q, t)$, linear interplate two control points $p$ and $q$, inline CPoint CBezier::lerp( CPoint &amp; p, CPoint &amp; q, double t ) { CPoint r = p * ( 1- t) + q * t; return r; }; $deBoor(C0, C1, C2, C3, t)$, compute a point on the Bezier curve at parametert inline CPoint CBezier::deBoor( CPoint &amp; c0, CPoint &amp; c1, CPoint &amp; c2, CPoint &amp; c3, double t ) { //Modify this procedure CPoint C01 = lerp( c0, c1, t ); CPoint C12 = lerp( c1, c2, t ); CPoint C23 = lerp( c2, c3, t ); CPoint C012 = lerp( C01, C12, t ); CPoint C123 = lerp( C12, C23, t ); CPoint C0123 = lerp( C012, C123, t ); return C0123; }; Bezier Surface Evaluation Algorithm Given a control net $C[4][4]$, and $2D$ parameters $uv$, evaluate the point on the Bezier surface constructed from the control net at the parameters $uv$, the algorithm evaluate the point p[k] on four Bezier curves controlled by points m_control_net$[k][0]$, m_control_net$[k][1]$, m_control_net$[k][2]$, m_control_net$[k][3]$, then evaluate the point on the Bezier curve controlled by $D[0], D[1], D[2], uv[3]$. inline CPoint CBezier::evaluate( CPoint2 uv ) { //Modify this procedure CPoint D[4]; for (int k = 0; k &lt; 4; k++) { D[k] = deBoor(m_control_net[k][0], m_control_net[k][1], m_control_net[k][2], m_control_net[k][3], uv[0]); } CPoint r = deBoor( D[0], D[1], D[2], D[3], uv[1] ); return r; }; Image Warpping The image is embedded in the unit square, the unit square is deformed by a nonlinear mapping $\phi :S \rightarrow \Re^2 $, where $S$ is the unit square. The mapping is modeled as Bezier surface, controlled by the control net. $$\phi(u, v) = \sum_{i=0}^3\sum_{j=0}^3B_3^i(u)B_3^j(v)C_{ij},$$where ${C_{ij} }$ form the control net,$B_3^i$ is the Bernstein polynomial, $$B_3^i(t) = C_3^i(1 − t)^i t^{3−i} ,$$ SummaryResult Fig. 4.1. Image Warpper On Brad Pitt Fig. 4.2. Image Warpper On Lake Fig. 4.3. Image Warpper On Wu Explain your algorithm for each requirement 1. The first algorithm generates Bezier Line by $Slerp(p, q, t)$ and $deBoor(C0, C1, C2, C3, t)$ The second algorithm generates Bezier Surface by iterating $deBoor(C0, C1, C2, C3, t)$]]></content>
      <categories>
        <category>Computer vision</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Computer vision</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[输入密码，查看文章。 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
</search>
